The time has come to redo sc-hacks from scratch.

Good luck...
* Roadmap, etc.
** Outline of Classes + Methods so far (2.1.2021)
*** Completed
**** Mediator, MediatorHandler: A Minimalist Proxy-space-like scheme
**** Class:atLibKey, fromLib: General scheme for instance storage + retrieval
**** Notifier: Observer pattern forr private object methods + asynchronous function calls
**** EventStream: play events as patterns, start/stop and modify stream contents at any point
**** OscTrig: Trigger EventStream (or other) events from Synths via =Sendtrig.kr=
**** Ratio: Rational number arithmetic
**** 6 new pattern classes
***** Pcontinue.sc
***** Pfseq.sc
***** Pfser.sc
***** Preduce.sc
***** Prseq.sc
***** Ptake.sc
**** Hacks: setup buffers + synthdefs at server boot

Load server options

*** Planned, under development
**** SynthCache

- Create a function for playing a SynthDef in the envir of a Player/Mediator, providing argument values from envir and mapping busses when needed. (get arguments from synthdesclib).
- Convert Functions to SynthDefs, send these to server. If needed, start a synth from the compiled SynthDef immediately after loading it, using "sync" mechanism.

Note: Wrapping functions to custom templates providing commonly used ugens (PlayBuf, GrainBuf, FFT/PV, SendTrig, etc.) should probably be done in additional methods to Function.

**** Player

Handle playing of synths in envir.  Several features are still under consideration, but it is unclear which classes should implement these and to what extent.

- Stop previous player when replacing with a new one (already done via Mediator. OK!)
- Auto set/map of parameters when relevant keys in the environment are set. A simpler and better version than that of the previous Player/SynthSource classes is envisaged.  Initialization at Synth creation is now delegated to SynthCache. Perhaps =SynthCache= should play the role of =Voice=, see below.
- Provide capabilities for processing audio input from other sources. These may be synths or patterns (!).

/Open question:/ =SynthCache- <-> =Voice=? Although it is possible to store and handle start/stop for several synths in the one environment of one Player instance, it seems too complicated to try to do that especially in combination with the feature of processing audio input in these players.  A wrapper class (candidate name: "Voice") can be envisaged to handle a synth-pattern pair, with multiple voices in the same envir, but still there seems to be unnecessary complexity in trying to implement that.  It may become clear thought, after investigating if the functionality described for =SynthCache= should be incorporated in a container named =Voice=. Irrespective of the naming of this class, its essential role would be to store state of the latest played synth element (i.e. SynthDef) and if present also pattern element (i.e. EventStream), so that they can be restarted.
** Issues Addressed: Name, State, Communication, Coordination, Techniques, Syntax
   :PROPERTIES:
   :DATE:     <2021-02-07 Sun 13:18>
   :END:
*** Name: Storing things under names.  Using namespaces
**** Storing things in Library
Previous approach: Registry, Singleton, NamedSingleton

Proposed new approach: Methods for Class: atLibKey, fromLib, removeLibKey. Define methods for getting instances of different classes by sending different messages to a symbol (buffer, window, filelist ...)

**** Storing things in Environments/Events

Using EnvironmentRedirect

*** State: Storing state to restart things

- For Synths: =SynthCache= (Underway)
- For Event-Patterns: =EventStream= (Completed)
- For Routines and Tasks: Use =Task= (Completed)

*** Communication: Sharing state between objects
*** Coordination: Keeping track of state and evaluating code in order (Synchronization)
*** Techniques (and Templates: Useful patterns for constructing objects)

Most common form is methods that return these templates.
Most general form of a template might be a function.
Other object types such as Event, Dictionary or Array are also conceivable.

**** Synth Templates

**** UGen Templates

**** New Patterns

**** Recipes "Language Patterns" ("Synth Patterns?")

*** Syntax

**** Class(new)

**** object.message

**** binary operator
** Phase 1: Initial Design Considerations + Preliminary work (till 25.1.2021)
*** 19 Jan 2021 08:55: Redo SourcePlayer as dictionary of Pattern/Synth making instances

 Cache Pattern and Synth players for a Player as NamedSingletons - or in dictionary inside Player's var =sourcemakers= or =sources=.

 The different makers instances are stored in a dictionary.  These could be accessed by a key that could be either the name of a synthdef (or possibly also a PatternDef), or the name of the class, in case that we want to use a generic SynthMaker or PatternMaker *(StreamMaker ?)* instance.  The additional advantage of this solution is that one could easily switch between different synth maker / stream maker templates, and cache a large number of these in a player (they could for example include the entire collection of currently loaded synthdefs).  Also, one could cache the last Maker played, so that play message without additional argument simply restarts the player using the last maker.

  *(Note: It is possible to resume EventStreams which have been stopped from the last point where they were stopped)* See this example:

 #+begin_src sclang
 //:+ wrap the code below in { }.fork if not using emacs sclang-snippets.
 p = EventPattern((dur: 1/10 * Pseq([1, 3, 1], inf), amp: 0.5, degree:
         Pn(Pseries(-9, 1, 35)
                 + Pseq([0, [0, 2], -2], inf),
                 inf)));
 e = p.play;
 loop {
         1.5.rrand(2.5).wait;
         e.stop;
         1.5.rrand(2).wait;
         e.start;
 }
 //:
 #+end_src

 _! TODO: The Pseq pattern in dur gets out of phase of the degree Pseq, even though they have the same length. This is probably due to stopping and restarting the EventPattern.  Check the code to see if there is some different treatment of the =dur= key from the other keys when stopping and/or starting the EventStream._

 The class could be returned by a method depending on the class of the source object.  For example:

 - Function returns SynthMaker (make synthdef from function and play it)
 - Symbol returns SynthMaker (make synth from synthdef's name)
 - Pattern returns PatternMaker

 Each such instance knows how to make its pattern stream or its synth.  It stores the source for making it as synthdef or StreamPlayer etc.

 Also, one may customize SynthMaker's to make them wrap a function or UGen inside a function providing for example different types of envelopes, filters, panners, buffer players, granulators, SendTrig.kr etc.

 It is unclear how to implement that.

 Solution 1: Define several subclasses of SynthMaker, each using a different kind of synth function wrapper, and to define different methods in Function which return this class.

 Solution 2: Pass the wrap function, and potentially additional arguments such as number of channels, parameter default values, etc. as additional arguments, and then use these parameters to create the wrapping function which is to be used inside the SynthMaker instance accessed by the player.

 In both of the above cases, the object passed to the Player should be not just a class, but an array containing the class and the function or additional parameters to use with it.  The Player accesses the instance of process maker from its sources dictionary and then plays it, passing additional arguments if needed.  An additional advantage of this approach is that a subarray contained in these arguments can be filtered and/or complimented by merging info from the SynthMaker or PatternMaker instance state (including for example default values of synth parameters), and state stored in the environment of the Player. (one should consider updating this info when a relevant key is set in the environment, to use as cache?).

 /Note: A new asSynthDef mechanism can be devised that will /

*** 19 Jan 2021 11:19 SynthMaker, PatternMaker details

 - Since an EventStream can continue from where it last stopped, these should be cached for each individual Player (not shared), using symbols as keys, in order to permit switching between different Streams!

 - In the case of symbols as SynthDef names, the SynthMaker may be accessed from a global dictionary containing all loaded synthdefs (SynthDefLib?)

 - In the case of Patterns, these should be stored in keys inside each Player where they have been used, because then the player can continue playing a pattern from the point at which it was previously stopped, and also each Player can hold its own custom patterns (rather than in a shared global repository of SynthDefs available on the server).

 Therefore, the Player can store in its =makers= dictionary a single SynthMaker using a SynthMaker instance as key, and several PatternMaker instances, using symbols as keys.

**** DRAFT: Starting synthdefs/patterns in voices of player. Old version (now replaced by new version below)
  - The process of choosing the Maker to use for the next Player.play has many steps or variants, and should be redesigned:

***** aPlayer.play(nil)
  Play the last played Maker (cached), or the default (possibly a Player or Maker class variable.
***** aPlayer.playSynthDef(synthdef)

***** aPlayer.playFunc(Function)
***** aPlayer.playPatternDef(name, proto)
  If PatternMaker is found under name, then add proto event to the keys of the maker. Start the pattern if it is not already playing.

  Else create a new pattern from the proto event and start it.

**** 21 Jan 2021 14:59 New methods for starting/stopping synthdefs/patterns in voices

***** aPlayer.start [or play ](\voice, optional: synthdef name, function, or event);

 (Use start or play as play as synonyms).

***** \aPlayername.stop(... voices);  : Stop the process(es) currently playing in Player \aPlayername.

 If no voices are specified, stop all voices.
 Otherwise, stop any voices found under the given voice names.

**** Shortcut methods for applying above methods to Player

 The above should in turn be constructed and issued from user input, translating from operators - methods:

***** aFunction +> aPlayerName (or Player)
      play Function in SynthMaker - making new temporary SynthDef.

***** aSymbol +> aPlayerName (or Player)
      play SynthDef named aSymbol, or default synthdef if none found.

***** anEvent +> aPlayerName (orPlayer), patternName
      play anEvent in pattern named patternName.  If pattern under patternName already exists, just merge the events keys to it. Else, create a new pattern based on anEvent.

**** Caching/setting/mapping synth parameters

 Can be done in SynthMaker. Following approach is slightly cpu costly at the time of the set up because, several new notifiers are added. but could lead to a clean and safe algorithm.

 - When the new synthdef is created or accessed, create a new array holding all paramname - value pairs to act as arg array for Synth(\defname, args ...). Get the values from the Player's envir, and if absent, from the SynthDef's defaults.

 - When receipt from server is received that the synth has started do:
   1. Store the started synth in var =process=.
   2. map any params that need to be mapped.
   3. add notifiers to the array from the environment of the player, whith actions:
      - set the parameter at the corresponding array slot to the value received
      - set the synth parameter to the value received.

 - When issuing release to stop the synth, do:
   - remove all notifiers from the parameter array. The synth is left to fade out without any parameter changes (!).
   - Set the array variable to a new empty array [].

**** Extra feature: Play arrays of synthdefs and/or patterns at each play, sharing the Players environment

 To consider! :

 This could be the default behavior.

 It means that the player performs set, map, free, release or event merging operations on each of the currently active processes.  The variable process should always contain an array.

*** DONE 19 Jan 2021 12:54 Pseq and Pser with function filter?
    CLOSED: [2021-01-19 Tue 14:12]

    - State "DONE"       from              [2021-01-19 Tue 14:12] \\
      Done. see Pfseq, Pfser.

 Devise a Pattern that plays like a Pseq but creates a new array for the Pseq at each new repetition, using a function.  The function should take the initial array, the previous array, and the number of repetitions as argument.

 The same with a Pser pattern, using the function to calculate the next index for accessing the list.

*** TODO 19 Jan 2021 16:42 check Queue:add: prevent running waitForBoot each time

 #+begin_src
 add { | action |
	 actions add: action;
	 if (inactive) {  // make sure server is booted, then eval first action
		 inactive = false; // must be before waitForBoot !!!!!!!
		 /* TODO:
			 check if it is possible to avoid running
		 preboot.(this) and waitForboot, when the server is already running.
		 */
		 preboot.(this);
		 server.waitForBoot({ // because waitForBoot messes with more delay
			 this.changed(\started, Process.elapsedTime);
			 this.prNext;
		 })
	 }
	 // if active, wait for sync message from server.
 }
 #+end_src

*** DONE 19 Jan 2021 20:04 document Queue sync mechanism to write own SynthDef loading code
    CLOSED: [2021-01-19 Tue 23:33]

    - State "DONE"       from "TODO"       [2021-01-19 Tue 23:33] \\
      done
 Find what messages from server are used to sync Queue, and which messages from lang trigger these messages.

**** Answer

 The queue works by evaluating the first (or next) function in its queue (here called =f=), and then *immediately* sending the message =/sync= to the server. Thus:

 1) First evaluate the function - which may start on the server some task such as loading a buffer or a synthder.
 2) Then send the message =/sync= to the server.

 This means that under normal conditions the server will start executing some time consuming task *before* receiving the =/sync= message.  If the task that was started by the evaluated function has already finished by the time that the server receives the subsequent =/sync= message, then the server will *immediately* send back the message =/synced=.  Else, the server will send back the message =/synced= as soon as it has finished the task which it was executing when it received the =/sync= message from Queue.

 The Queue sends the =/sync= message together with a unique id which it obtains from =UniqueID.next=.  In response to this, the server sends back the message =/synced= together with the same id.  The OSCFunc of Queue compares the id received with the one it just generated, and thus makes sure to respond to the =/synced= message which corresponds to the =/sync= message that it just sent. When the ids match, Queue executes the next function in its queue list.

**** What this means for syncing the loading of synthdefs and starting of synths

 For starting of synths we can test this by including a synth.set message in a function that creates a synth, just after Synth.new, and after that syncing, and then in the next action also sending a synth.set message. According to today's tests, one can send both synth.set and synth.map to a synth right after Synth.new, without syncing. But we may want to test this again ...  . However it would be more interesting to test the same thing with generating a synthdef from a function and sending it to the server, and then immediately trying to start a synth from it before syncing. This should definitely not work. The synth should only be possible to generate in the next function added to the Queue after the synthdef loading function. This next function is guaranteed to run after the SynthDef has been loaded, and therefore it is guaranteed that this function can start a synth with this synthdef.

*** TODO 19 Jan 2021 22:42 Redo synthdef freeing  + controls + bus mechanism from makeSynth of SynthPlayer.

 This code is complex and needs rebuilding step-by-step.

 Connecting an array of parameters as receiver of update messages from the players envir may improve the code.

 One can get rid of the code that tests if the player is still waiting for the synth to start (which has occasional errors), and use sync instead.

 Check again the code for testing whether the player stopped when its synth stops - which is, do not stop if another synth is in its place.

**** 20 Jan 2021 16:19 Name for class playing Synths/Patterns inside a Player: Voice

 A Voice can play both synths and patterns.  Patterns are always played inside a synth which provides the fade envelope for them.

 Multiple Voices can play in one Player at the same time.  They are stored in a dictionary by name (symbol).  Access is given via the adverb in operators addressed to player.  (this replaces the previous hardly used scheme envir, player with a new scheme: player, voice).

**** TODO 20 Jan 2021 12:41 initial considerations

 - use asPlayerSynthDef to obtain synthdef
 - get arguments and synthdef name from the synthdef obtained.
 - code draft to create synthdef and optionally start the synth:
   - ={ newSynthDef.add }.sync;
   - if needed to start synth immediately, then also do: ={ synth = Synth(<synthdef name>) }.sync= to create the synth as soon as the synthdef was loaded.

 - *Freeing temp synthdefs!*: when asked to play a new func, then always free the previously stored synthdef, and replace it by the synthdef created from the new func provided.

 *Important (1):* To ensure that only temp synthdefs are freed, playing synthdef and playing symbols should provide different classes to handle this.  Their differences are:
   - playSynthFunc ::
     - generate new synthdef
     - use sync to ensure that the synth starts after the synth def is loaded.
   - playSynthSymbol :: (assumes that the def is already loaded)
     - obtain synthdef from SynthDescLib by name. If not found, issue warning and use \default synthdef instead.
     - play synth immediately *(NOTE: Must test this extensively first to ensure that it always works!)* (The alternative is to enclose the synth creation and argument settin/mapping funcs in 2 separate sync statements.).

 *Important (2):* When playing a new synthdef the previous synthdef must be freed *only when it is a temp synthdef!*.  A safe and simple way to decide this is to store the SynthDefMaker that creates or accesses the synthdef each time that a new synthdef is used.  Thus, if the synthdef maker which created the previously played synthdef is a =Symbol2SynthDef=, it will *not* free the synthdef, because it is a permanent def.  But if the synthdef maker which created the previously played synthdef is a =Func2SynthDef=, it *will free* the synthdef, because it is a temporary def. Here is a draft for implementing this:

 The choice of class can be done through method =Function:asSynthDefMaker= vs. =Symbol:asSynthDefMaker=.

 In conclusion, the new implementation of Player stores a single instance of SynthPlayer in its players dictionary.  This instance is responsible for playing both functions and symbols as synths. It is accessed by =playSynth= or possibly by either =playSynthFunc= or =playSynthSymbol= - chosen upstream in the chain of computation. Thereafter:

 - =playSynthFunc= creates an instance of =Func2SynthDef= to obtain its synthdef.
 - alternatively =playSynthSymbol= creates an instance of =Symbol2SynthDef= to obtain its synthdef.
 - *Before storing the newly obtained synthdefmaker in variable synthDefMaker*, the SynthPlayer instance sends to the previously stored synthDefMaker instance the message =freeDefIfTemp=.   If the previously stored synthDefMaker is a =Symbol2SynthDef= it does not free.  Else if the instance is a =Func2SynthDef= it does free the temporary def that it holds.

*** TODO 20 Jan 2021 11:16 custom asSynthDef for Player
    :PROPERTIES:
    :DATE:     <2021-01-20 Wed 11:16>
    :END:

**** 20 Jan 2021 12:22 workaround for providing own gated envelopes in synthdef functions

 The method GraphBuilder:wrapPlayerOut does not work if the synthdef function provided contains a =\gate= control, because it tries to provide =\gate= itself
  - which is not accepted by the builder.  However, one can switch this off if one provides nil as value of =fadeTime=.  The workaround for doing this requires the =\gate= control to be defined as an argument of the synthdef function, i.e. it will not work if the gate control is defined inside the function with =\gate.kr(0)=.  The presence of a gate argument in the function can be detected like this:

  #+begin_src sclang
  { | gate = 0 | }.def.argNames.includes(\gate);
  #+end_src

 Based on the above, it is possible to provide an alternative method calling =Function:asSynthDef= with the right argument values:

 #+begin_src sclang
 + Function {
    asPlayerSynthDef { | fadeTime = 0.02 |
      ^this.asSynthDef(
        fadeTime: if (this.def.argNames includes: \gate) {
          nil
        }{
          fadeTime
        },
        name: SystemSynthDefs.generateTempName
      );
    }
}
#+end_src

 Note: Additionally GraphBuilder:wrapOut should be modified to provide a regular control argument =out= instead of scalar =i_out=, so that synths can change their output channel.

**** TODO 19 Jan 2021 22:18 enable customization of envelopes in GraphBuilder:wrapPlayerOut

 This is an optional additional feature to consider. Define a new method GraphBuilder:wrapPlayerOut which enables one to provide the envelope to be used as additional argument.

  The relevant code in GraphBuilder is:
  #+begin_src sclang

   GraphBuilder {
	  /*
		  TODO: add an argument for customizing makeFadeEnv.
		  Make it possible to either provide the function itself,
		  or the name of a method to call,
		  Define different methods for different types of fade envelopes.
		  Symbol \none might build as envelope just the number 1,
		  thus canceling the envelope making and allowing the user
		  to write their envelope + gate in the function.
	  */
	  *wrapPlayerOut
  #+end_src

*** 20 Jan 2021 14:47 New Player implementation notes
    :PROPERTIES:
    :DATE:     <2021-01-20 Wed 14:48>
    :END:

**** Recent features added (in sc-hacks):

 Include pattern streams in environment. At each new play, the next value of the stream is broadcast to the player.

**** Recent features in preparation (in sc-hacks):

 Trigger players from SendTrig players.  Many-to-many connections enabled.

**** New features planned

***** Play any number of synths or patterns concurrently

 (This was originally envisaged, but never really used. The old implementation foresaw multiple players stored in/responding to one environment. The new implementation delegates the playing to [Synth]Players stored in a dictionary inside the Player.)

 Implementation is discussed in the following subsection
****** combine patterns and synths: play patterns always inside of synths

 This solves several problems while also adding the extra feature of providing customizeable fadein/out (as well as possibly also other effects to play the pattern in).

 Short discussion: Using different classes for pattern and synth players presents the problem that we cannot keep the state of the instance if it is replace.  This means that we would either have to keep two sets of sub-players - in which case we have to stop instances of either set, at the appropriate key, or we have to store a pair of synth and pattern player in one object, and switch between the two accordingly.

 On the other hand, if we play a pattern inside a synth (routing its output to the input of the synth), then we can also have fadein and out from the synth. We can keep playing the pattern while the synth is fading out.  This would be a desirable consistent behavior for cross-fading when playing different alternating patterns or synths in sequence in a player.

***** Provide customizeable filter functions for adapting input from any key in the environment

 Short discussion: This can be done by customizing the Notifier actions for each key in the internal player.  Defaults can be provided and customized for each internal player.

*** TODO 20 Jan 2021 18:31 alternative pattern playing mechanism in EventStream

 This is radical but everything indicates it should be done. Current mechanism is so complex that I could not find even a way to locally modify the parent event of an event when playing (see also subsection to the present section below. [[*21 Jan 2021 09:58 devise and new functions for defaultParentEvent keys.][21 Jan 2021 09:58 devise and new functions for defaultParentEvent keys.]]).

 It should become possible to build the pattern playing mechanism from scratch in EventStream, like this:

 - Add a function that processes all keys returned by the Event.
 - Bypass (remove) the event playing function, substituting a function that returns a new event with the keys-value pairs obtained by evaluating "next" on all keys of the event being played.
 - Pass this event as argument to a function.
 - At first, program the scheduling mechanism that repeatedly evaluates the stream value getting mechanism at time intervals determined by the value of dur.
 - Then start adding functions to process keys e.g. to convert degrees to frequency, calculate duration based on legato etc.

 Start by exploring the way EventStream creates its events with method next.
 (See files in Snippets/EventPattern210120)

**** 21 Jan 2021 12:38 step 0: setting the parent event to the event played.

 If the event to be played has no parent event, set its parent event from a copy of some default parent event provided by the class itself or by an argument to the play function.

 This step should be done once only in response to a play method sent to the EventStream.  Subsequent play methods that evaluate each subsequent event generated from the EventStream do not substitute its parent event.  There should thus be 2 separate methods:

 ...

**** 21 Jan 2021 12:36 step 1: creating the event to play from the EventStream

 Create a new event =targetevent= and fill it with the values obtained from the streams in the event being played:

 For each key-stream pair in the event:
 1. Issue a this.changed(\nextevent) notification that can be caught by objects previously generated by the play function to stop them (release synths etc.), or by other concerned objects (gui, remote osc clients, etc.);
 2. get the next value of the stream by evaluating it inside the event itself with event.use({ streamvalue.next }).
 3. Store the value obtained in the previous step into =targetevent= at the same key as where it was obtained from.
 4. If a nil is encountered, then abort the loop and also cancel rescheduling (i.e. stop playing because the eventstream has finished).

***** 21 Jan 2021 15:32 EventStream next method already works as needed for the new implementation

 #+begin_src sclang
 //:
 a = EventPattern((dur: 1)).asStream;
 { a.next.postln; } ! 10;
 //:
 a = EventPattern((dur: Pn(1, 3))).asStream;
 { a.next.postln; } ! 10;

 #+end_src

**** 21 Jan 2021 12:37 step 2: evaluating the function stored in the play key.

***** Easy change of play functions
 Since this is produced by a stream like all other keys, the type of play function can change individually for each played event (midi, osc, fx, setting busses, playing other event patterns .... etc.).

***** Playing multiple functions at each time.

 Also it is possible to execute multiple play functions for one event.  So the general statement to enable this should always treat the play function as an array and iterate over each of its elements.

  #+begin_src sclang
  targetevent.use({ ~play.asArray do: _.value });
  #+end_src

***** collecting arguments for play functions from the event

****** For synth playing functions:

  Iterate over the arguments required by the a synth play function collecting the value of the key corresponding to the argument (or if absent, the defalt value!).

 Loaded SynthDefs may cache their argument arrays with default values to save time.

***** connecting event processes to event for future control: easy control of portamento vs. restart

 synths created by the play function can either specify a fixed duration or ask to be notified for release when the next event plays or the pattern stops.

 It should be relatively easy also to control whether the synth is to restart at the next event or simply to set its control parameters to the values obtained by the next event (mono-playing).


***** 22 Jan 2021 03:27 simple lookahead. (very easy - please continue this example)

 #+begin_src sclang
 //:
 a = EventStream((dur: 0.2, play: Pseries(1, 1, 10)));
 AppClock.sched(0, {
	 var next;
	 next = a.next;
	 a.changed(\newEvent); // previous voices stop in response to this
	 next.play.postln;     // new voices start here
	 if (next.notNil) { next.dur } { a.changed(\ended)};
 });
 #+end_src

***** 22 Jan 2021 03:34 Lookahead

 In order to do a glissando between one note and the next one (portamento), one needs to know the duration of the note, and the pitches of both the current and the next note.

 One could collect a small subset of the events generated by the EventStream into a cache, and send all of these to the play function at each time.  This is essential for playing events that include movement that depends on both the present start condition and the next start condition as for example, a portamento between the current and the next pitch, taking place during the entire duration of the event.

 Implementing this requires some careful work.  Suggested approach:  Collect n events in an array, start by playing the first one, and then rotate the array to bring the next one first, and set the next obtained event to the slot peviously containing the past event.

 Testing behavior of rotate:
 #+begin_src sclang
 { | i | i.post; ', '.post; (1..10).rotate(i).postln; } ! 10;
 "that was not the right order".postln;
 "retrying with negative values: ".postln;
 (0..-10) do: { | i | i.post; ', '.post; (1..10).rotate(i).postln; };
 #+end_src

 Rotation algorithm to try would be:

 #+begin_src sclang
 // assumes past, present, future are instance vars of EventStream
 present = event = future[0];
 future = future rotate: -1;
 future.put(future.size - 1, this.next); // !!! this.next !!!
 present.play;
 past = past add: present;
 #+end_src
***** 22 Jan 2021 09:25 Make EventStream available to main playing event

***** 22 Jan 2021 09:31 Add past, present, future to EventStream

***** 22 Jan 2021 09:19 New Event methods: =stream=, =tstream=

****** =stream= : Create EventStream and play that.

****** =tstream= : Create EventStream and play that listening to =/tr= messages from SendTrig.

 =anEvent.tstream(key ... ids);

 Create OSCFunc listening to =/tr= and triggering anEvent.play each time.

 If key is provided, then the event sets that key to the value sent by SendTrig.
 A variant could be to make key a function =func= and evaluate that function with =event.use(func.(value, id))= where =value= and =id= are the value and id received from SendTrig. This would give generalized access to the entire event for more modifications.

 If =ids.size == 0=, then no argTemplate filter is given.
 Else a the OSCFunc is constructed using an =argTemplate= filter. Implementation note: If more than one ids are possible in one =argTemplate=, then one OSCFunc does the job. Else multiple OSCFuncs must be constructed, one for each id.

 The event plays at each receipt of =/tr=.

******* Register dt - time between triggers

 if =~lastTime= is nil, set =~dt= to 0.
 Else set =~dt= to =~lastTime - Process.elapsedTime=.

***** Playing sub-patterns at each event. =fPlay=?

 Can be delegated to play functions.  Should be relatively easy. A play event (key) inside the streasm played can be a function calling another event inside it to play as stream, while filtering duration and optionally also other keys to adapt them to the current playing context.  For this, an easy way to add filters to keys should be devised - if possible without modifying the event that is playing.  That could be an event passed as argument to the play message. This might have to be a new method name as Event:play is already taken, and does not include this mechanism.  Perhaps =filterPlay=, or =fPlay=?

 =fPlay= could be something like:

 #+begin_src sclang
 + Event {
	 fPlay { | filterEvent |
		 var playEvent;
		 playEvent = this;
		 filterEvent !? {
 // Copy the Event because you are modifying it.
 // The original event may be needed for playing other modified copies,
 // and also for storing in past history:
			 playEvent = this.copy;
			 filterEvent.keysValuesDo: { | key, value |
				 playEvent.put(key, value.(this[key]));
			 };
		 };
		 playEvent.play;
	 }
 }
 #+end_src

 To use this when playing events generated from an EventStream, one would have to wrap it in a function stored inside the =play= key.

***** URGENT 22 Jan 2021 10:11 define methods (or classes?) for customizing the play function inside an event.
      CLOSED: [2021-01-22 Fri 10:15]

 ... [explain how event is played in EventStream by the function stored in =~play=] ...

 It is best to define these as Classes because they exist as functions independent of an EventStream or Event.  (The function which they contain is evaluated within the context of the event with =use=.  Must check whether this =use= must be repeated inside or not. Probably it is best to set the =play= event of the default parent event to a default =PlayEvent= instance which does =event use: (myFunc.value)=, and derive custom subclasses from it which generate their own custom function with customizable parameter values inherited within the closure context of the instance that created them.

 Examples of functions or classes for customizing the play function in EventStream are:

****** Dtranspose (transpose degree)
****** Mtranspose (midi Transpose)
****** Ctranspose (cent Transpose)
****** Ftranspose (frequency Transpose (multiply!))
****** ScaleDur
****** Delay
****** Arpeggiate
****** Repeat
****** Subpattern

 An interesting exercise might be to create a subclass of Subpattern that replays a section of the past or future events of the EventStream within the duration of the present event, while possibly transposing them or otherwise scaling their parameters.

****** Gamaka (or Portamento)

 (could also use values past and present events)

 Play a control-rate curve inside a parameter.

 Arguments:

 - =key= :: the key to which the control rate bus will be mapped
 - =gFunc= :: ...

 Some delay is involved to wait for the custom function to play before mapping. This can be minimized by playing pre-loaded synthdefs.  Custom shapes are possible in these by foreseeing custom envelopes (see examples under Env in SC doc, also quoted in the present file.)

 The mechanism is a bit complex as we need to create a bus, load or access a control synthdef, play it in the bus, start the main synth, and map the parameter in the bus. When the event ends, free the control synth and the bus.

***** 22 Jan 2021 11:26 Modifying the event of EventStream on the fly: methods =set=, =add=

 - =set(argEvent)= :: Set the event of the EventStream to argEvent
 - =add(argEvent)= :: Add the contents of argEvent to the event of the EventStream

***** Other on-the-spot algorithmic generation of events

 ...

**** Step 3: schedule the next =targetevent=

 If no event was produced (=targetevent= is =nil=), then signal this.stopped. All played events will be notified, and will stop if needed.

 If an event was produced, then schedule the next event to be played after =~dur= seconds.  The parent event of the eventstream event should always contain a =dur= key with a default value.  To ensure this implement following recipe:



**** Providing default synthdefs for unspecified or missing defnames

 The play func can do this very easily.

**** TODO 21 Jan 2021 14:07 review how to pass an envelope shape as argument to a synth

 Start with these examples from https://doc.sccode.org/Classes/EnvGen.html

 #+begin_src sclang
 (
 SynthDef(\help_Env_newClear, { |out = 0|
     var env, envctl;
     // make an empty 4 segment envelope
     env = Env.newClear(4);
     // create a control argument array
     envctl = \env.kr(env.asArray);
     Out.ar(out,
         SinOsc.ar(EnvGen.kr(envctl, \gate.tr), 0, 0.3) // the gate control is a trigger
     );
 }).add;
 )

 Synth(\help_Env_newClear, [\gate, 1, \env, Env([700,900,900,800], [1,1,1], \exp)]); // 3 segments

 // reset then play again:
 Synth(\help_Env_newClear, [\gate, 1, \env, Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)]);

 // the same written as an event:
 (instrument: \help_Env_newClear, gate: 1, env: Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)).play;
 #+end_src

 #+begin_src sclang
 // Changing an Env while playing
 (
 SynthDef(\env, { arg i_outbus=0;
     var env, envctl;

     // make a dummy 8 segment envelope
     env = Env.newClear(8);

     // create a control argument array
     envctl = \env.kr( env.asArray );

     ReplaceOut.kr(i_outbus, EnvGen.kr(envctl, doneAction: Done.freeSelf));
 }).add;
 )

 (
 SynthDef(\sine, { |out, freq = 440|
     Out.ar(out, SinOsc.ar(freq, 0, 0.2));
 }).add;
 )

 f = Bus.control(s, 1);
 f.set(800);

 // use f's control bus value for frequency
 // i.e. *map* the control to read from the bus
 a = Synth(\sine, [freq: f.asMap]);

 Synth(\env, [i_outbus: f, env: Env([700, 900, 900, 800], [1, 1, 1]*0.4, \exp)]);

 Synth(\env, [i_outbus: f, env: Env([1000, 1000, 800, 1000, 900, 1000], [1, 1, 1, 1, 1]*0.3, \step)]);

 a.free;
 f.free;
 #+end_src

**** CANCELED 21 Jan 2021 09:58 devise and new functions for defaultParentEvent keys.
     CLOSED: [2021-01-21 Thu 11:10]

  This route is now abandoned. Resuming with rebuilding event playing in pattern approach from scratch.

  COULD NOT GET THIS TO WORK WITH EventPattern or Pbind or anything.

  Route tried:

  Preparing. Look at these, then add your own ~freq function to defaultParentEvent.

  #+begin_src sclang
  a = ();
  a.parent; //parent is nil
  ().play;
  a.parent; // parent is defaultParentEvent
  a.parent[\freq] // get the key of a's parent
  a.parent.freq; // cannot eval default freq function outside of its event
  a use: { a.parent.freq; }; // but can evaluate it inside its event, like this
  #+end_src

  If you want to use a modified version of the defaultParentEvent locally, without changing the default global behavior, then you should make a copy and modify that one. The following shows that modifying the parent event in an event after playing is inherited when playing another event:

  #+begin_src sclang
  a.parent[\freq];
  a.parent[\freq] = 1000;
  //:
  b = ().play;
  b.parent[\freq];
  #+end_src

***** Solution 1 (did not work - see file where this method is defined.

  Since defaultParentEvent is not accessible outside an Event (see class definition code!), write a method like this to do the modification:

  #+begin_src sclang
  + Event {
	   setParentKey_ { | key, newValue |
		   // preserve previous changes to parent!
		   parent = (parent ? defaultParentEvent).copy;
		   parent.put(key, newValue);
	   }
  }
  #+end_src

***** Solution 2 (not found a way to make this work!)

  Use a Pfunc.  However I could not find a way to evaluate the Function of a Pfunc using the event itself as environment.  (FuncStream uses currentEnvironment, so it might be possible to do this with event.push, but this looks like a risky workaround).

  See this:

  #+begin_src sclang
  Pbind(\freq, Pfunc({ | in |
	  postf("testing degree: %\n", ~degree);
	  postf("testing inval: %\n", in);
	  1200; }
  ), \degree, 10).play;
  #+end_src
*** 22 Jan 2021 12:59 Keeping EventStream simple by adding behaviors as keys

 Some extra features could be added as behaviors through keys assigned to corresponding Classes.  But some are so simple that it is better to add them as methods to EventStreasm.

 - Count the number of events played: Return =past.size=.
 - Calculate the total duration of the pattern played so far. Sum durations of past events.  Better to do that than to incrementally add durations of partial playings - as an EventStream can be paused and restarted many times.

*** 22 Jan 2021 13:06 Conditionally change the value of a key

 Add a key that contains a condition and then goes event.put[key, newValue] when that condition is met. This is much better in most cases than going

 =Pseq([Pn(val1, n1), Pn(val2, n2) ... etc ])=

 Especially if conditions do not depend on counting times but on other stuff.

*** 22 Jan 2021 14:03 is there a Pcount? (or anything that works like it?)

 Initialize on 0 (or any given start number).
 At each iteration, increment the current count number by 1 (or any given increment, or function).
 Optionally reset to start.
 Optionally change the starting point / increment / function.

*** 22 Jan 2021 14:06 get - set: Important operations on the event of the EventStream.

 For the actions described in the title and in the following subsections: At which level (EventStream, Event, inside event keys?) should these be made available and how? (Method?/Class?).

 I seem to be repeating this thought but should settle on one implementation and discuss its various use cases!

**** Get the value of a key to operate on it (if it is a stream for example).

**** Set the value of a key
*** 21 Jan 2021 06:50 explore patterns that operate on the result of other patterns

**** 20 Jan 2021 22:32 1. define new kind of pattern that continues outputting the last value produced by the pattern that precedes it, for n number of times.

  Say the pattern is called Pcontinue.


  For example:

  Pcontinue(Pseries(1, 1, 3), 3).asStream.nextN(8)

  should produce:

  [1, 2, 3, 3, 3, 3, nil, nil]

**** 21 Jan 2021 07:58 Ptake: Pattern returning the first n elements of a stream.
     :PROPERTIES:
     :DATE:     <2021-01-21 Thu 08:00>
     :END:

 #+begin_src sclang
 Ptake(Pseries(1, 1, 6), 2).asStream.nextN(5);
 #+end_src

 Returns:

 #+begin_src sclang
 [ 1, 2, nil, nil, nil ]
 #+end_src

**** 21 Jan 2021 06:51 2. Play less elements from a pattern at each repeat.

 For example:

 #+begin_src sclang
 Preduce(Pseries(1, 1, 5)).asStream.all;
 #+end_src

 should produce:

 #+begin_src sclang
 [1, 2, 3, 4, 5, 1, 2, 3, 4, 1, 2, 3, 1, 2, 1]
 #+end_src

***** Implementation notes 21 Jan 2021 09:53

 Extend Ptake to take less notes at each repetition.

 Requires specifying the initial number of elements to take because this is not known at the outset (and cannot be inferred from the source pattern because it may be infinite in length).

***** Earlier notes (before 21 Jan 2021 09:51)

 This is probably possible with Pgate.  The doc file is not clear to me. Must study more.  Also, since Pgate requires an event, it is probably better to code a new pattern that does the job without requiring a pattern.

 Examples from doc file:

  #+begin_src sclang
  //:
  (
  Pbind(
      \degree, Pseq((0..7), inf),
	  \amp, 0.5,
      \step, Pseq([false, false, false, true, false, true, false], inf),
      \octave, Pgate(Pwhite(5,7), inf, \step),
      \dur, 0.2
  ).play
  )
  //: Pn advances Pgate each time its subpattern is repeated
  (
  Pbind(
	  \amp, 0.5,
	  \octave, 6,
      \degree, Pn(Pseq((0..7)), inf, \step),
      \mtranspose, Pgate(Pseq((0..4), inf), inf, \step),
      \dur, 0.2
  ).play
  )


  //: Two different Pgates advanced at two different rates
  (
  Pbind(
	  \amp, 0.5,
	  \octave, 6,
      \scale,    Scale.minor,
      \foo, Pn(Pseq((0..2)),inf,  \step1),
      \degree, Pn(Pseq((0..7).mirror), inf, \step),
      \ctranspose, Pgate(Pwhite(0,5), inf, \step) + Pgate(Pseq([0,7,0,-7], inf), inf, \step1),
      \dur, 0.2
  ).play
  )
  #+end_src
** Phase 2: New EventStream + New currentEnvironment API strategy (25.1.2021 ff.)
*** 25 Jan 2021 18:24 Redesign of EventStream complete
    :PROPERTIES:
    :DATE:     <2021-01-25 Mon 18:24>
    :END:

See work in repository =aliran=.
Description to follow after transfer to present repository.

*** 25 Jan 2021 18:30 =Mediator=: Stop processes in currentEnvironment before replacing them

**** Preliminaries: =Mediator=: A New ProxySpace-like class and its api
 Write a new dipatcher for EnvironmentRedirect

 The Class using the new dispatcher will be called =Mediator= or =WakalaNafasi=

 To activate it, go:

 #+begin_src sclang
 Enviroment.startDispatcher;
 // or:
 Mediator.activate;
 #+end_src

 To deactivate it, go:

 #+begin_src sclang
 Enviroment.stopDispatcher;
 // or:
 Mediator.deactivate;
 #+end_src

**** How it works

It pushes itself to the =currentEnvironment= and translates requests to set a variable to a synth or a pattern to an action that stops a synth or pattern before replacing it.  The following classes will stop previous contents of a key before being stored:

- Synth
- EventStreamPlayer

This means that in the following cases, the element previously stored in the environment variable will be stopped before storing the new element:

#+begin_src sclang
~myvoice = Synth(\default);
~myvoice = { SinOsc.ar(440, 0, 0.2).dup }.play;
~myvoice = Pbind(\dur, 0.3).play;
#+end_src

Discussion:

Advantages:
- Simple use

Disadvantages:
- No state is saved. Thus no restarting or resuming is possible.

In the case of EventStream it is possible to keep state, so this is hnadled differently than Synth and EventStreamPlayer.

Also Player can keep state, so here again the behavior is different.

**** 25 Jan 2021 22:36 Test first prototype

Evaluate following lines at different times:

#+begin_src sclang
Mediator.push; // start using mediator
// then execute any of the following lines in different order:
~b = { WhiteNoise.ar(0.1).dup }.play;
~b = { SinOsc.ar(400 + 2000.rand, 0, 0.1).dup }.play;
~b = Pbind(\dur, 0.1 rrand: 0.4, \degree, Pwhite(10, 20)).play;
// finally restore the original currentEnvironment:
Mediator.pop; // stop using mediator
#+end_src

*** 28 Jan 2021 18:41 Simpler Alternatives to Registry and Notification
    :PROPERTIES:
    :DATE:     <2021-01-28 Thu 18:42>
    :END:

See files =Notifier.sc= and =StateWithoutVars.sc=

See EventStream:addTrig and OscTrig for use case ...

The following notes are obsolete.
**** 27 Jan 2021 17:06 Store and retrieve additional objects for any object
     CLOSED: [2021-01-28 Thu 18:38]

30 Jan 2021 11:29: *These are earlier notes and should be scrapped - replaced by better description:*

Note:  the global and local access functionality one either has to store the objects under 2 different perspectives, or one has to use search in order to provide the functionality of either one of the perspectives.  Therefore this approach is abandoned.  We keep only the global aspect, as a modified, minimalist approach to what was previously the Registry class, and the classes related to it, Singleton, NamedSingleton etc.

When adding new functionality to a class, it is often needed to add some instance variables in order to store state needed for that functionality.  This presents some problems in coding:

To add variables, either one has to edit the source code of the class concerned, or one has to create a subclass of that class, and add the variables to the subclass.  This has several disadvantages or problems:

1. Adding variables and/or subclasses leads to bloating of the code and can make it difficult to follow, because the roles of variables and their interdepences become more complex.
2. One may not want to modify the code of classes defined by other programmers because they belong to libraries whose modification requires checking by the authors.

One way to add state to an object without adding variables, is to store its state in a dictionary and access it using the object as key.  An example of this pattern is the dependant pattern in SuperCollider.  This uses classvar =dependantsDictionary= of =Object= in order to store the dependants of an object.  However =dependantsDictionary= is used for the special purpose of updating dependants and therefore should not be used for general storage purposes.  Here we propose to use the Library (Library.global) to store such objects, for 2 reasons: 1. =Library.global= is designed in SCClassLibrary for the express purpose of storing objects. 2. The implementation of Library as MultiLevelIdentityDictionary is handy for storing objects under a path composed from a sequence of keys, which is something handy for the needs of the functionality discussed here. Different approaches to the same issue, using class variables, are found in the Ndef/Tdef/Pdef classes of JITLib and in OSCFunc and its sister classes.



***** Use case analysis: Global storage of instances under ids, local storage for a single instance

 The first use case for the proposed Lib strategy is the implementation of a method addTrig in EventStream.

 #+begin_src sclang
 anEventStream.addTrig(id)
 #+end_src

 =anEventStream.addTrig(id)= : add an instance of =OSCTrig= which contains an OSCFunc listening to =/tr= with argTemplate =[id]=, and when receiving an OSC at that address, sends to the receiver (=anEventStream=) the message =trig(id)=.  Note:

 - An =EventStream= instance should be able to add multiple trigs on different ids.
 - Also, an =OSCTtrig= instance should be able to send =trig= to multiple instances of =EventStream=.

 In order to be able to function as above, the system must perform the following tasks:

****** =EventStream= obtains =OSCTrig= instance under =id= key.

 In order to add itself to an =OSCTrig= instance, an =EventStream= should be able to obtain an =OSCTrig= instance with a specified =id=.  If an =OSCTrig= instance with that =id= already exists, it should get that instance and use it. Else, a new instance should be created and stored under that =id= so that it is accessible for future use by any =EventStream= or other object that needs it.

****** =EventStream= finds one or all =OSCTrig= instances that it is connected to

 In order to remove itself from an =OSCTrig= instance, an =EventStream= should be able to know if it aready has that instance.

 Therefore, an =EventStream= should store all of the =OSCTrig= instances that it is connected to, using their =id=s as keys.

***** Method proposal replacing NamedSingleton/Registry behavior

 #+begin_src sclang
 aClass.libGet(key ... args);
 #+end_src

 an object could instance of class using method above, as follows:

 #+begin_src sclang

 #+end_src




***** more (eariler) draft
 #+begin_src sclang
 aClass.libStore(key ... args);
 #+end_src




***** Storage formats
      :PROPERTIES:
      :DATE:     <2021-01-28 Thu 14:12>
      :END:

****** 1. class - id (= key) - value

****** 2. object - class (= varname = key) - id  - value

******* (Alternative: class - object - dict, or class - object -key - value)

***** Test case with =EventStream.addTrig(id)=

 - get an =OSCTrig= instance =ot= corresponding to given =id=.
 - =ot= is stored in Library.global under =[OSCTtrig, id]=
 - =ot= is also stored in Library.global under =[thisEventStream, OSCTrig, id]=

***** API: Methods for adding, accessing, replacing objects

****** DRAFT 2 : Suggested names

******* libAt

 #+begin_src sclang
 anObject.libAt(class, key ... args)
 #+end_src

******* obtain

 (see synonyms from https://www.thesaurus.com/browse/obtain :
  access achieve attain collect earn gain gather glean have pick up procure purchase reach realize reap receive recover retrieve secure seize take win
 )

******* libPut, libPadd

 #+begin_src sclang
 anObject.libPut(class, key )
 #+end_src

****** DRAFT 1 - very primitive, before analysis
******* =putLib= store an object for the receiver under a key

   Key defaults to class =Nil=. Other classes or types of keys can be used to store / retrieve the object.

******* =atLib= return object stored for receiver under a key.

   Key defaults to class =Nil=. Other classes or types of keys can be used to store / retrieve the object.

******* =addLib= add an object to a set of objects stored under a key

******* =takeLib= remove an object from a set of objects stored under a key

******* =repLib=  replace an object from a set of objects stored under a key with another object

*** 30 Jan 2021 18:03 SynthCache: construct synth args and start synths in an environment

Features (draft):

- store argume names from a synthdef
- construct argument array for starting a synth from a synthdef.
- evaluate argument array consruction function in an envir providing default values for starting the synth

Possible extra features (maybe use separate class for these):

- handle both synthdefs existing in SynthDescLib and newly constructed synthdefs from functions.
- use sync to ensure that synths are created after their synthdef has been loaded.

*** 31 Jan 2021 23:02 Rhythmical pattern notation with SendTrig based on rational numbers
    :PROPERTIES:
    :DATE:     <2021-01-31 Sun 23:03>
    :END:

Notation principle - first thoughts:

**** ="x-x-x---x-".b(reldur)= and ="x-x-x---x-".f(reldur)= :

=reldur= can be an Integer, Float, or Ratio. (See class =Ratio= in present library).

We should compare two appraches:  Converting =reldur= to =Ratio= type, or leaving it as it is.  In either case, we should also consider how to wait additional time after the end of the pattern until the beginning of the next beat.

- treat the string as beats, x means play the beat, - means do not play the beat.
- Calculate the number of beats in the string.
- Calculate the duration of the beat so that the entire duration of the notated rhythm pattern will sum up to the argument (SimpleNumber or Ratio) in terms of a the current reference beat duration, where (SimpleNumber or Ratio) could signify:

***** method =b= (beat)

The duration of *one* beat in the pattern becomes equal to the value of =reldur= multiplied by the duration of the refererence beat.

***** method =f= (fit)

The duration of each beat in the pattern is calculated so that the duration of the *entire pattern* becomes equal to the value of =reldur= multiplied by the duration of the refererence beat.


**** Implementation

2 Approaches (for different styles of playing):

1. as a pattern for insertion into an event for playing the usual way
2. as a synth sending SendTrig based on an impulse pattern.

To create the impulse pattern in approach 2, use Impulse.kr with a constant frequency (steady i.e. equal beat lengths), and use a demand ugen outputting a series of 0 or 1 in order to filter out those beats which should be sent (1) or remain silent (0). Alternatively, use TDuty and specify the duration to the next beat individually.  Stop the synth after the last beat.

***  1 Feb 2021 10:57: Mediator + syncMap + SynthCache + wrappers: Radically simplify Player
    :PROPERTIES:
    :DATE:     <2021-02-01 Mon 10:59>
    :END:

Things to try:

- =Synth("defname", [args...]).map(...);= If map does not find the Synth, then try =Synth("defname", [args...]).sync.map(...);=
- Delegate that to a method inside SynthCache, which adds =sync= if the SynthDef needs to be added first.
- Releasing synths replaced inside the Players envir can be handled by making the envir a Moderator.  Very simple.
- Add methods =addInput=, =addOutput= which add the synth of added players before or after that of the present player, and set their =in= or =out= in their envirs to route to the Player's bus.  Chains of multiple players can be created reliably this way.
- Expand Mediator to set or map parameters of its synths when keys are set. This reproduces the behavior of Player from the older implementation of =sc-hacks

***  2 Feb 2021 07:07 SynthCache -> Voice. Implementation Notes
    :PROPERTIES:
    :DATE:     <2021-02-02 Tue 07:07>
    :END:

****  3 Feb 2021 23:00 SynthCache notes

3 Methods needed:

***** =func2Def=:
 - get def from defname

***** =symbol2Def=

compile def fomr function

***** makePlayfunc

based on the results of the =func2Def= or =symbol2Def=, construct a function that uses envir to get the arguments and creates a synth. It should also map its controls if needed and connect it to future changes.

***  7 Feb 2021 12:44 Saving process state to restart ("cache")

2 cases where we need to save process state:

- Synths :: Name of synthdef or source function + argument / target state
- EventStream :: Event + current position in stream

Note: To make it possible to restart Routine-like processes, we use Task instead. Task is able to start-stop-restart and reset.

Current status of dealing with the above:

- EvenStream :: already solved in EventStream, with subclasses =SimpleEventStreamPlayer= and =EventGetter=
- Synths :: Underway - with =SynthCache= [and/or =Voice=]

*** 20 Feb 2021 20:04 Reviewing Queue
    :PROPERTIES:
    :DATE:     <2021-02-21 Sun 22:44>
    :END:

Sync is needed to ensure that an object exists on the Server before trying to do something with that object.  The main cases are:

- Buffer :: =aBuffer.setn(...)= works only if the buffer exists.
- SynthDef / Synth :: =Synth(\newdef)=; works only if the SynthDef has been loaded.
- Synth set, map, free etc. :: Commands sent to a Synth require that the synth exists.
- Node set, after etc. :: Commands set to a Node require that the node exists.

Next sections discuss each of the above cases, giving examples.

**** Sync required to set values in new Buffer

When sending values to a buffer with =setn=, one must make sure that the buffer exists. Otherwise the values are not sent to the buffer.  Example:

#+begin_src sclang
b = Buffer.alloc(Server.default, 2 ** 9, 1);
b.setn(0, 127); // no error message is issued, but the value was not set!
// error message is issued: /b_get index out of range:
b.get(0, { | val | postf("my value at 0 was %\n", val )});
#+end_src

The above works if one syncs:

#+begin_src sclang
{
	b = Buffer.alloc(Server.default, 2 ** 9, 1);
	Server.default.sync; // ensure that buffer exists before setting values
	b.setn(0, 127);
	// the value is set and accessed.
	b.get(0, { | val | postf("my value at 0 was %\n", val )});
}.fork;
#+end_src

Interestingly, if running within a forked thread with Server.default.sync, then getting and plotting after setting does not require an extra sync. The reason for this is that in this case the Server.default.sync statement inside the fork delays the entire thread of execution, so it is guaranteed that the setn and get and plot statements are executed in order after the buffer is allocated.

(By contrast, the q methods (q, qsetn, qget, etc.) execute the corresponding operation on the buffer independently from the main thread. This means that all of them have to be used if not running in a thread with a sync statement inserted after the Buffer was created.)

#+begin_src sclang
{
        var b;
        b = Buffer.alloc(Server.default, 2 ** 9, 1);
        Server.default.sync; // ensure that buffer exists before setting values
        b.setn(*[(0..(2**9-1)), Signal.sineFill(2**9, [1, 1], [0, pi])].flop.flat);
        b.get(5, { | val | "value at 5 was: %\n", postln; });
        b.plot;
}.fork(AppClock); // AppClock required to enable plot. (Alternative: 'defer')
#+end_src

Expla
**** Sync required when sending a new SynthDef, before making a Synth from it

***** Wait for SynthDef to load in server before starting synth with it

****** Wrong: No waiting
#+begin_src sclang
//:Must wait for SynthDef to load in server before starting synth with it.
var defname; // make sure to create new synthdef for each test.
defname = format("synctest%", UniqueID.next);
SynthDef(defname, { | freq = 440 |
	  var src;
	  src = SinOsc.ar(freq, 0, 0.1).dup;
	  Out.ar(0, src * Env.adsr.kr(2, \gate.kr(1)));
}).add;
a = Synth(defname); /* getting error:
	  *** ERROR: SynthDef synctest not found
	  FAILURE IN SERVER /s_new SynthDef not found
*/
#+end_src

****** Correct: Using sync in a routine

This is correct:
#+begin_src sclang
//:
a.release;
//:Using sync
{
	  var defname; // make sure to create new synthdef for each test.
	  defname = format("synctest%", UniqueID.next);
	  SynthDef(defname, { | freq = 440 |
		  var src;
		  src = SinOsc.ar(freq, 0, 0.1).dup;
		  Out.ar(0, src * Env.adsr.kr(2, \gate.kr(1)));
	  }).add;
	  Server.default.sync;
	  a = Synth(defname);
}.fork;
//:
// a.release;
#+end_src

***** Wait for synth to start before setting or mapping (only if using ={ }.play=)

When creating a Synth with =Synth.new()= (or: =Synth(...)=), one can set or map its controls immediately, and it is not necessary to sync:

 #+begin_src sclang

 //:================================================================
 //:set after starting a synth - no sync needed after Synth.new:
 a = Synth("synctest");
 a.set(\freq, 1200); // no sync needed
 //:mapping. Testing Bus sync + map sync.
 b = Bus.control;
 b.set(60.rrand(70).midicps);
 a = Synth("synctest");
 a.map(\freq, b.index);
 #+end_src

When creating a Synth with ={ /* function */ }.play=, sync is needed to set or map its controls. However, there is a noticeable time interval between the actual start of the synth and the receipt of the synth signal in sclang. This results in an audible jump in the control parameters:

****** Trying without sync (does not work)
#+begin_src sclang

//: ================================================================
//:Sync needed if creating the synth with Function:play
//: sync needed for set:
a = { | freq = 440 |
	  SinOsc.ar(freq, 0, 0.1).dup * Env.adsr.kr(2, \gate.kr(1));
}.play;
a.set(\freq, 1200); // sync needed
#+end_src

****** Using sync (works, but with audible jump)

#+begin_src sclang

//:Above example, synced - glitch is audible because of delay in receiving sync
{
	  a = { | freq = 440 |
		  SinOsc.ar(freq, 0, 0.1).dup * Env.adsr.kr(2, \gate.kr(1));
	  }.play;
	  Server.default.sync;
	  a.set(\freq, 1200); // sync needed

}.fork;
#+end_src

****** Similar examples using map

#+begin_src sclang

//: ================ sync also needed for map
b = Bus.control;
b.set(60.rrand(70).midicps);
a = { | freq = 440 |
	  SinOsc.ar(freq, 0, 0.1).dup * Env.adsr.kr(2, \gate.kr(1));
}.play;
a.map(\freq, b.index); // sync needed
#+end_src

#+begin_src sclang

//:above mapping example, synced
{
	  var b;
	  b = Bus.control;
	  b.set(80.midicps);
	  a = { | freq = 440 |
		  SinOsc.ar(freq, 0, 0.1).dup * Env.adsr.kr(2, \gate.kr(1));
	  }.play;
	  Server.default.sync;
	  a.map(\freq, b.index); // glitch is audible because of delay in receiving sync

}.fork;
#+end_src
** Phase 3: Simple +> operator
   :PROPERTIES:
   :DATE:     <2021-06-02 Wed 16:18>
   :END:

New operators - radical simplification:
*** =+>= Play event or function. Always start new process
    :PROPERTIES:
    :DATE:     <2021-06-02 Wed 16:23>
    :END:

 #+begin_src sclang
 () +> \test;  // play event in EventStream \test. Always start new EventStream
 { WhiteNoise.ar(0.1) } +> \test;  // play Function in  \test
 #+end_src

*** A player playing in a symbol must have its own environment



*** =++>= Add / modify parameter value(s) in existing process

#+begin_src sclang
440 ++>.freq \test; // set freq parameter of test to 400
0.1 ++>.dur \test; // set dur parameter of test to 0.1;
#+end_src

*** SynthPlayer?: hold synthdef name?
    :PROPERTIES:
    :DATE:     <2021-06-14 Mon 10:10>
    :END:

Not needed. Get SynthDef name from synth.
Allocation of new nodeID is done in Synth:startInEnvir.
** Playing Functions and Synths in currentEnvironment
   :PROPERTIES:
   :DATE:     <2021-06-14 Mon 17:04>
   :END:
*** First thing to implement: SynthDef:synthMsgFromEnvir

Construct the message for starting a synth, obtaining initial argument values from currentEnvir.

This *must* be done in SynthDef, because SynthDef must send it with =doSend= in order to start a synth.
The message array must be sent together with =doSend= as an argument, because this is required by Server interface.
See: http://doc.sccode.org/Reference/Server-Command-Reference.html

#+begin_quote
/d_recv

Receive a synth definition file.
bytes	buffer of data.
bytes	an OSC message to execute upon completion. (optional)
#+end_quote

*** List of steps, methods, etc

to help distribute the code in appropriate methods between SynthDef, Synth and Symbol:

**** SynthDef:synthMsgFromEnvir

(See above)

**** Function:playInEnvir
***** create synthdef

Note: Requires access to =~fadeTime= in =currentEnvironment=.

***** send synthdef to server

**** Synth:playInEnvir

 Arguments: =def=, =addAction=. Their defaults are as follows:

 - def: Obtain from value of =defName= inside Synth.
 - addAction: =\addToHead=

***** obtain synthDesc from synthDef



***** obtain arguments from synthdesc
***** obtain values for arguments from environment
***** obtain target + server + addAction from environment or method arguments

 addAction should be argument to startInEnvir

***** create synth creation message from arguments
***** send synth creation message to server
***** register synth to track its state
***** map buses to synth parameters
***** add synth as dependant of envirionment


** Mediator Environment - overall design
:PROPERTIES:
:DATE:     <2021-08-09 Mon 14:18>
:END:

Mediator is an Environment Redirect used in sc-hacks-redux as ProxySpace.
A Mediator can be pushed to become the current environment.  When a value is stored in a key of a Mediator, the Mediator issues a =\changed= message, which dependants can use to update their state to reflect the change in the Mediator environment.

When a new value is stored in a key that currently contains a SynthPlayer or EventStream, then the currently contained SynthPlayer or EventStream is stopped. This is because storing another value in that key causes the previous value to become inaccessible in the environment, which means that we cannot stop it later even if we want to.

*** TODO Performing code blocks with a Mediator as currentEnvironment
**** sclang-style
#+begin_src sclang
\aMediator use: {
	~inbus = Bus.audio(1);
	~freq = 100;
	(dur: 0.1).splay;
}
#+end_src
**** using snippets

#+begin_src sclang
//:voice1
// wrap the block below in a \voice1 use: {  } block
~inbus = Bus.audio(1);
~freq = 100;
(dur: 0.1).splay;
#+end_src

** Extensions to snippet syntax
*** =//+routine= wrap in fork statement

Store routine under =\routine=.
Store name defaults to =\default=.

*** =//*loopedroutine= wrap in fork statement

Store routine under =\loopedroutine=.
Store name defaults to =\default=.
** Hacks class: configure startup
:PROPERTIES:
:DATE:     <2021-08-09 Mon 15:42>
:END:




* Ideas to follow/develop
  :PROPERTIES:
  :DATE:     <2021-03-20 Sat 11:16>
  :END:
** Cycles
*** Yann - ICS cycle project
    :PROPERTIES:
    :DATE:     <2021-03-20 Sat 11:18>
    :END:

https://scsynth.org/t/supercollider-extension-cycle/2389
#+begin_quote
Hi SuperCollider users,

I had the idea a few years ago to collect all numerical algorithm forming cycle.

I started the work as a lisp library called cl-cycle 4 and it is still under development.

Then, as a SuperCollider user, I wanted to implement these algorithms to use it directly in SC language and naturally share it.

All the algorithms return an array with the cycle itself prepended by its `path’ if it exists. In this way, to access to the cycle, you have just to select the last item of the array, and for the path — or the cycle by default — the first item.

This SuperCollider extension cycle 10 can be installed directly on the Platform.userExtensionDir or with the package manager Quarks by evaluating Quarks.install("https://github.com/yannics/cycle")

An Instance of use:

Pbind(\degree, [1,2,3,4,1].kaprekar(5).pattern(inf, true, false), \dur, 3.euclidean(8, true).pattern(inf)/4).play;

You are welcome to participate in this work by completing or improving the existing algorithms, and adding any algorithm fitting the theme of cyclicity.
Any contribution will be mentioned.
Any suggestions and feedback are welcome.

Enjoy!
#+end_quote
*** Chaotic sound synthesis, cybernetics, feedback
    :PROPERTIES:
    :DATE:     <2021-03-20 Sat 11:24>
    :END:

See folder Code4Porting/cybernetics_and_feedback.
*** Wave Terrain Synthesis
    :PROPERTIES:
    :DATE:     <2021-03-20 Sat 11:52>
    :END:

https://scsynth.org/t/wave-terrain-synthesis/3424/9

#+begin_quote
A very first step in a attempt to get turbulence in a terrain is to see what Perlin noise does. It is quite wild. I just “displaced” the <x,y> based on the value of the noise. As it is a deterministic noise the resulting value will always be the same given the same input. I should not use the actual value of the noise itself, but the rate of change of the noise value. Then apply a few steps of it.

Perlin: The Book of Shaders: Noise 1

Turbulence algorithm description: Reference Section 4 1

An other nice noise to have in SuperCollider is Worley noise aka cellular noise: The Book of Shaders: More noise

(Can we use images for terrain? 16 bit grey scale, linear gamma. *.pgm files would be the simplest format. The “scan range” in the synth would have to be limited <0,1> and with interpolation between pixels.) EDIT: got a WaveTerrain from CSV file working.

#+end_quote

* specialized Mediator Environments for triggers, beat arrays etc.
:PROPERTIES:
:DATE_DONE: [2022-10-21 Fri 12:14]
:END:

** kr synths playing impulse triggers into busses: \triggers
** kr synths filtering triggers through beat arrays: \beats
** buffers containing beat arrays: \beatbufs
* specialized operators for triggers, beat arrays etc.
:PROPERTIES:
:DATE_DONE: [2022-10-21 Fri 12:25]
:END:

** Operations needing (!?) operators:

*** SimpleNumber to Symbol: Start or set rate of trigger kr synth

The synth should *both* write impulses to a bus *and* use SendReply to send OSC
to lang at each beat.

*** Array to Symbol: send array to beats buffer
*** Symbol to Symbol: connect trigger synth to beat filtering synth
*** NOTE: 2 ways to connect beat filtering synth to playing Synth or EventStream
**** For Synths:
***** hardwire it in the synth play func by naming the bus that should be read
***** Write it as In.kr(\trig.kr(0)) and set the trig dynamically!
**** For EventStreams: connect these to OSC message sent by beat synth

** SimpleNumber || \symbol;
Start or set rate of { Impulse.kr(SimpleNumber) } @>.triggers \symbol;
** Array
