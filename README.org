# 18 Jan 2021 22:59
The time has come to redo sc-hacks from scratch.

Good luck...
* Roadmap, etc.
** 19 Jan 2021 08:55: Redo SourcePlayer as dictionary of Pattern/Synth making instances

Cache Pattern and Synth players for a Player as NamedSingletons - or in dictionary inside Player's var =sourcemakers= or =sources=.

The different makers instances are stored in a dictionary.  These could be accessed by a key that could be either the name of a synthdef (or possibly also a PatternDef), or the name of the class, in case that we want to use a generic SynthMaker or PatternMaker *(StreamMaker ?)* instance.  The additional advantage of this solution is that one could easily switch between different synth maker / stream maker templates, and cache a large number of these in a player (they could for example include the entire collection of currently loaded synthdefs).  Also, one could cache the last Maker played, so that play message without additional argument simply restarts the player using the last maker.

 *(Note: It is possible to resume EventStreams which have been stopped from the last point where they were stopped)* See this example:

#+begin_src sclang
//:+ wrap the code below in { }.fork if not using emacs sclang-snippets.
p = EventPattern((dur: 1/10 * Pseq([1, 3, 1], inf), amp: 0.5, degree:
        Pn(Pseries(-9, 1, 35)
                + Pseq([0, [0, 2], -2], inf),
                inf)));
e = p.play;
loop {
        1.5.rrand(2.5).wait;
        e.stop;
        1.5.rrand(2).wait;
        e.start;
}
//:
#+end_src

_! TODO: The Pseq pattern in dur gets out of phase of the degree Pseq, even though they have the same length. This is probably due to stopping and restarting the EventPattern.  Check the code to see if there is some different treatment of the =dur= key from the other keys when stopping and/or starting the EventStream._

The class could be returned by a method depending on the class of the source object.  For example:

- Function returns SynthMaker (make synthdef from function and play it)
- Symbol returns SynthMaker (make synth from synthdef's name)
- Pattern returns PatternMaker

Each such instance knows how to make its pattern stream or its synth.  It stores the source for making it as synthdef or StreamPlayer etc.

Also, one may customize SynthMaker's to make them wrap a function or UGen inside a function providing for example different types of envelopes, filters, panners, buffer players, granulators, SendTrig.kr etc.   

It is unclear how to implement that. 

Solution 1: Define several subclasses of SynthMaker, each using a different kind of synth function wrapper, and to define different methods in Function which return this class.  

Solution 2: Pass the wrap function, and potentially additional arguments such as number of channels, parameter default values, etc. as additional arguments, and then use these parameters to create the wrapping function which is to be used inside the SynthMaker instance accessed by the player.

In both of the above cases, the object passed to the Player should be not just a class, but an array containing the class and the function or additional parameters to use with it.  The Player accesses the instance of process maker from its sources dictionary and then plays it, passing additional arguments if needed.  An additional advantage of this approach is that a subarray contained in these arguments can be filtered and/or complimented by merging info from the SynthMaker or PatternMaker instance state (including for example default values of synth parameters), and state stored in the environment of the Player. (one should consider updating this info when a relevant key is set in the environment, to use as cache?).

/Note: A new asSynthDef mechanism can be devised that will /

** 19 Jan 2021 11:19 SynthMaker, PatternMaker details



- Since an EventStream can continue from where it last stopped, these should be cached for each individual Player (not shared), using symbols as keys, in order to permit switching between different Streams!

- In the case of symbols as SynthDef names, the SynthMaker may be accessed from a global dictionary containing all loaded synthdefs (SynthDefLib?)

- In the case of Patterns, these should be stored in keys inside each Player where they have been used, because then the player can continue playing a pattern from the point at which it was previously stopped, and also each Player can hold its own custom patterns (rather than in a shared global repository of SynthDefs available on the server).

Therefore, the Player can store in its =makers= dictionary a single SynthMaker using a SynthMaker instance as key, and several PatternMaker instances, using symbols as keys.

- The process of choosing the Maker to use for the next Player.play has many steps or variants, and should be redesigned:

*** aPlayer.play(nil) 
Play the last played Maker (cached), or the default (possibly a Player or Maker class variable.
*** aPlayer.playSynthDef(synthdef)
The 
*** aPlayer.playFunc(Function)
*** aPlayer.playPatternDef(name, proto)
If PatternMaker is found under name, then add proto event to the keys of the maker. Start the pattern if it is not already playing.

Else create a new pattern from the proto event and start it. 

*** Shortcut methods for applying above methods to Player

The above should in turn be constructed and issued from user input, translating from operators - methods: 

**** aFunction +> aPlayerName (or Player)
     play Function in SynthMaker - making new temporary SynthDef.

**** aSymbol +> aPlayerName (or Player)
     play SynthDef named aSymbol, or default synthdef if none found.

**** anEvent +> aPlayerName (orPlayer), patternName
     play anEvent in pattern named patternName.  If pattern under patternName already exists, just merge the events keys to it. Else, create a new pattern based on anEvent.

**** nil +> aPlayerName (or Player), patternName
   or: \aPlayerName.pplay(\patternName); (see next section for discussion of synonyms)
     play pattern patternName, or empty Pattern =()= if none found.

 Note: This is to avoid having to use a different operator distinguish playing a Pattern by PatternMaker name and a Synth by SynthDef name.
 
**** \aPlayername.stop;  : Stop the process(es) currently playing in Player \aPlayername.

*** Caching/setting/mapping synth parameters

Can be done in SynthMaker. Following approach is slightly cpu costly at the time of the set up because, several new notifiers are added. but could lead to a clean and safe algorithm.

- When the new synthdef is created or accessed, create a new array holding all paramname - value pairs to act as arg array for Synth(\defname, args ...). Get the values from the Player's envir, and if absent, from the SynthDef's defaults. 

- When receipt from server is received that the synth has started do: 
  1. Store the started synth in var =process=.
  2. map any params that need to be mapped.
  3. add notifiers to the array from the environment of the player, whith actions:
     - set the parameter at the corresponding array slot to the value received
     - set the synth parameter to the value received.

- When issuing release to stop the synth, do:
  - remove all notifiers from the parameter array. The synth is left to fade out without any parameter changes (!).
  - Set the array variable to a new empty array [].

*** Extra feature: Play arrays of synthdefs and/or patterns at each play, sharing the Players environment

To consider! : 

This could be the default behavior.

It means that the player performs set, map, free, release or event merging operations on each of the currently active processes.  The variable process should always contain an array. 

** DONE 19 Jan 2021 12:54 Pseq and Pser with function filter?
   CLOSED: [2021-01-19 Tue 14:12]

   - State "DONE"       from              [2021-01-19 Tue 14:12] \\
     Done. see Pfseq, Pfser.

Devise a Pattern that plays like a Pseq but creates a new array for the Pseq at each new repetition, using a function.  The function should take the initial array, the previous array, and the number of repetitions as argument.

The same with a Pser pattern, using the function to calculate the next index for accessing the list.

** TODO 19 Jan 2021 16:42 check Queue:add: prevent running waitForBoot each time

#+begin_src 
add { | action |
	actions add: action;
	if (inactive) {  // make sure server is booted, then eval first action
		inactive = false; // must be before waitForBoot !!!!!!!
		/* TODO:
			check if it is possible to avoid running
		preboot.(this) and waitForboot, when the server is already running.
		*/
		preboot.(this);
		server.waitForBoot({ // because waitForBoot messes with more delay
			this.changed(\started, Process.elapsedTime);
			this.prNext;
		})
	}
	// if active, wait for sync message from server.
}
#+end_src

** DONE 19 Jan 2021 20:04 document Queue sync mechanism to write own SynthDef loading code
   CLOSED: [2021-01-19 Tue 23:33]

   - State "DONE"       from "TODO"       [2021-01-19 Tue 23:33] \\
     done
Find what messages from server are used to sync Queue, and which messages from lang trigger these messages.

*** Answer

The queue works by evaluating the first (or next) function in its queue (here called =f=), and then *immediately* sending the message =/sync= to the server. Thus: 

1) First evaluate the function - which may start on the server some task such as loading a buffer or a synthder. 
2) Then send the message =/sync= to the server.

This means that under normal conditions the server will start executing some time consuming task *before* receiving the =/sync= message.  If the task that was started by the evaluated function has already finished by the time that the server receives the subsequent =/sync= message, then the server will *immediately* send back the message =/synced=.  Else, the server will send back the message =/synced= as soon as it has finished the task which it was executing when it received the =/sync= message from Queue. 

The Queue sends the =/sync= message together with a unique id which it obtains from =UniqueID.next=.  In response to this, the server sends back the message =/synced= together with the same id.  The OSCFunc of Queue compares the id received with the one it just generated, and thus makes sure to respond to the =/synced= message which corresponds to the =/sync= message that it just sent. When the ids match, Queue executes the next function in its queue list. 

*** What this means for syncing the loading of synthdefs and starting of synths

For starting of synths we can test this by including a synth.set message in a function that creates a synth, just after Synth.new, and after that syncing, and then in the next action also sending a synth.set message. According to today's tests, one can send both synth.set and synth.map to a synth right after Synth.new, without syncing. But we may want to test this again ...  . However it would be more interesting to test the same thing with generating a synthdef from a function and sending it to the server, and then immediately trying to start a synth from it before syncing. This should definitely not work. The synth should only be possible to generate in the next function added to the Queue after the synthdef loading function. This next function is guaranteed to run after the SynthDef has been loaded, and therefore it is guaranteed that this function can start a synth with this synthdef.

** TODO 19 Jan 2021 22:42 Redo synthdef freeing  + controls + bus mechanism from makeSynth of SynthPlayer.

This code is complex and needs rebuilding step-by-step.

Connecting an array of parameters as receiver of update messages from the players envir may improve the code.

One can get rid of the code that tests if the player is still waiting for the synth to start (which has occasional errors), and use sync instead.  

Check again the code for testing whether the player stopped when its synth stops - which is, do not stop if another synth is in its place.

*** TODO 20 Jan 2021 12:41 initial considerations

- use asPlayerSynthDef to obtain synthdef
- get arguments and synthdef name from the synthdef obtained.
- code draft to create synthdef and optionally start the synth:
  - ={ newSynthDef.add }.sync;
  - if needed to start synth immediately, then also do: ={ synth = Synth(<synthdef name>) }.sync= to create the synth as soon as the synthdef was loaded.

- *Freeing temp synthdefs!*: when asked to play a new func, then always free the previously stored synthdef, and replace it by the synthdef created from the new func provided. 

*Important (1):* To ensure that only temp synthdefs are freed, playing synthdef and playing symbols should provide different classes to handle this.  Their differences are: 
  - playSynthFunc ::
    - generate new synthdef
    - use sync to ensure that the synth starts after the synth def is loaded. 
  - playSynthSymbol :: (assumes that the def is already loaded)
    - obtain synthdef from SynthDescLib by name. If not found, issue warning and use \default synthdef instead. 
    - play synth immediately *(NOTE: Must test this extensively first to ensure that it always works!)* (The alternative is to enclose the synth creation and argument settin/mapping funcs in 2 separate sync statements.). 

*Important (2):* When playing a new synthdef the previous synthdef must be freed *only when it is a temp synthdef!*.  A safe and simple way to decide this is to store the SynthDefMaker that creates or accesses the synthdef each time that a new synthdef is used.  Thus, if the synthdef maker which created the previously played synthdef is a =Symbol2SynthDef=, it will *not* free the synthdef, because it is a permanent def.  But if the synthdef maker which created the previously played synthdef is a =Func2SynthDef=, it *will free* the synthdef, because it is a temporary def. Here is a draft for implementing this: 

The choice of class can be done through method =Function:asSynthDefMaker= vs. =Symbol:asSynthDefMaker=.

In conclusion, the new implementation of Player stores a single instance of SynthPlayer in its players dictionary.  This instance is responsible for playing both functions and symbols as synths. It is accessed by =playSynth= or possibly by either =playSynthFunc= or =playSynthSymbol= - chosen upstream in the chain of computation. Thereafter: 

- =playSynthFunc= creates an instance of =Func2SynthDef= to obtain its synthdef.
- alternatively =playSynthSymbol= creates an instance of =Symbol2SynthDef= to obtain its synthdef.
- *Before storing the newly obtained synthdefmaker in variable synthDefMaker*, the SynthPlayer instance sends to the previously stored synthDefMaker instance the message =freeDefIfTemp=.   If the previously stored synthDefMaker is a =Symbol2SynthDef= it does not free.  Else if the instance is a =Func2SynthDef= it does free the temporary def that it holds.  

** TODO 20 Jan 2021 11:16 custom asSynthDef for Player
   :PROPERTIES:
   :DATE:     <2021-01-20 Wed 11:16>
   :END:

*** 20 Jan 2021 12:22 workaround for providing own gated envelopes in synthdef functions

the method GraphBuilder:wrapPlayerOut does not work if the synthdef function provided contains a =\gate= control, because it tries to provide =\gate= itself
 - which is not accepted by the builder.  However, one can switch this off if one provides nil as value of =fadeTime=.  The workaround for doing this requires the =\gate= control to be defined as an argument of the synthdef function, i.e. it will not work if the gate control is defined inside the function with =\gate.kr(0)=.  The presence of a gate argument in the function can be detected like this: 

 #+begin_src sclang
 { | gate = 0 | }.def.argNames.includes(\gate);
 #+end_src

Based on the above, it is possible to provide an alternative method calling =Function:asSynthDef= with the right argument values: 

#+begin_src sclang
+ Function { 
   asPlayerSynthDef { | fadeTime = 0.02 |
     ^this.asSynthDef(
       fadeTime: if (this.def.argNames includes: \gate) {
         nil				
       }{
         fadeTime				
       },
       name: SystemSynthDefs.generateTempName
     );
   }
}
#+end_src

Note: Additionally GraphBuilder:wrapOut should be modified to provide a regular control argument =out= instead of scalar =i_out=, so that synths can change their output channel. 

*** TODO 19 Jan 2021 22:18 enable customization of envelopes in GraphBuilder:wrapPlayerOut

This is an optional additional feature to consider. Define a new method GraphBuilder:wrapPlayerOut which enables one to provide the envelope to be used as additional argument. 

 The relevant code in GraphBuilder is: 
 #+begin_src sclang

  GraphBuilder {
	 /*
		 TODO: add an argument for customizing makeFadeEnv.
		 Make it possible to either provide the function itself,
		 or the name of a method to call,
		 Define different methods for different types of fade envelopes.
		 Symbol \none might build as envelope just the number 1, 
		 thus canceling the envelope making and allowing the user 
		 to write their envelope + gate in the function. 
	 */
	 *wrapPlayerOut 
 #+end_src
