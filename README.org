# 18 Jan 2021 22:59
The time has come to redo sc-hacks from scratch.

Good luck...
* Roadmap, etc.
** 19 Jan 2021 08:55: Redo SourcePlayer as dictionary of Pattern/Synth making instances

Cache Pattern and Synth players for a Player as NamedSingletons - or in dictionary inside Player's var =sourcemakers= or =sources=.

The different makers instances are stored in a dictionary.  These could be accessed by a key that could be either the name of a synthdef (or possibly also a PatternDef), or the name of the class, in case that we want to use a generic SynthMaker or PatternMaker *(StreamMaker ?)* instance.  The additional advantage of this solution is that one could easily switch between different synth maker / stream maker templates, and cache a large number of these in a player (they could for example include the entire collection of currently loaded synthdefs).  Also, one could cache the last Maker played, so that play message without additional argument simply restarts the player using the last maker.

 *(Note: It is possible to resume EventStreams which have been stopped from the last point where they were stopped)* See this example:

#+begin_src sclang
//:+ wrap the code below in { }.fork if not using emacs sclang-snippets.
p = EventPattern((dur: 1/10 * Pseq([1, 3, 1], inf), amp: 0.5, degree:
        Pn(Pseries(-9, 1, 35)
                + Pseq([0, [0, 2], -2], inf),
                inf)));
e = p.play;
loop {
        1.5.rrand(2.5).wait;
        e.stop;
        1.5.rrand(2).wait;
        e.start;
}
//:
#+end_src

_! TODO: The Pseq pattern in dur gets out of phase of the degree Pseq, even though they have the same length. This is probably due to stopping and restarting the EventPattern.  Check the code to see if there is some different treatment of the =dur= key from the other keys when stopping and/or starting the EventStream._

The class could be returned by a method depending on the class of the source object.  For example, 

- Function returns SynthMaker (make synthdef from function and play it)
- Symbol returns SynthMaker (make synth from synthdef's name)
- Pattern returns PatternMaker

Each such instance knows how to make its pattern stream or its synth.  It stores the source for making it as synthdef or StreamPlayer etc.

Also, one may customize SynthMaker's to make them wrap a function or UGen inside a function providing for example different types of envelopes, filters, panners, buffer players, granulators, SendTrig.kr etc.   

It is unclear how to implement that. 

Solution 1: Define several subclasses of SynthMaker, each using a different kind of synth function wrapper, and to define different methods in Function which return this class.  

Solution 2: Pass the wrap function, and potentially additional arguments such as number of channels, parameter default values, etc. as additinal arguments, and then use these parameters to create the wrapping function which is to be used inside the SynthMaker instance accessed by the player.

In both of the above cases, the object passed to the Player should be not just a class, but an array containing the class and the function or additional parameters to use with it.  The Player accesses the instance of process maker from its sources dictionary and then plays it, passing additional arguments if needed.  An additional advantage of this approach is that a subarray contained in these arguments can be filtered and/or complimented by merging info from the SynthMaker or PatternMaker instance state (including for example default values of synth parameters), and state stored in the environment of the Player. (one should consider updating this info when a relevant key is set in the environment, to use as cache?).
** 19 Jan 2021 11:19 SynthMaker, PatternMaker details

- They cannot store playing state - because there is only one per player - but there can be many SynthMakers and/or PatternMakers cached in a Player's sources.

- Since an EventStream can continue from where it last stopped, these should be cached for each individual Player (not shared), using symbols as keys, in order to permit switching between different Streams!

- In the case of symbols as SynthDef names, the SynthMaker may be accessed from a global dictionary containing all loaded synthdefs (SynthDefLib?)

- In the case of Patterns, these should be stored in keys inside each Player where they have been used, because then the player can continue playing a pattern from the point at which it was previously stopped, and also each Player can hold its own custom patterns (rather than in a shared global repository of SynthDefs available on the server).

Therefore, the Player can store in its =makers= dictionary a single SynthMaker using a SynthMaker instance as key, and several PatternMaker instances, using symbols as keys.

- The process of choosing the Maker to use for the next Player.play has many steps or variants, and should be redesigned:

*** aPlayer.play(nil) 
Play the last played Maker (cached), or the default (possibly a Player or Maker class variable.
*** aPlayer.playSynthDef(synthdef)
The 
*** aPlayer.playFunc(Function)
*** aPlayer.playPatternDef(name, proto)
If PatternMaker is found under name, then add proto event to the keys of the maker. Start the pattern if it is not already playing.

Else create a new pattern from the proto event and start it. 

*** Shortcut methods for applying above methods to Player

The above should in turn be constructed and issued from user input, translating from operators - methods: 

**** aFunction +> aPlayerName (or Player)
     play Function in SynthMaker - making new temporary SynthDef.

**** aSymbol +> aPlayerName (or Player)
     play SynthDef named aSymbol, or default synthdef if none found.

**** anEvent +> aPlayerName (orPlayer), patternName
     play anEvent in pattern named patternName.  If pattern under patternName already exists, just merge the events keys to it. Else, create a new pattern based on anEvent.

**** nil +> aPlayerName (or Player), patternName
   or: \aPlayerName.pplay(\patternName); (see next section for discussion of synonyms)
     play pattern patternName, or empty Pattern =()= if none found.

 Note: This is to avoid having to use a different operator distinguish playing a Pattern by PatternMaker name and a Synth by SynthDef name.
 
**** \aPlayername.stop;  : Stop the process(es) currently playing in Player \aPlayername.

*** Caching/setting/mapping synth parameters

Can be done in SynthMaker. Following approach is slightly cpu costly at the time of the set up because, several new notifiers are added. but could lead to a clean and safe algorithm.

- When the new synthdef is created or accessed, create a new array holding all paramname - value pairs to act as arg array for Synth(\defname, args ...). Get the values from the Player's envir, and if absent, from the SynthDef's defaults. 

- When receipt from server is received that the synth has started do: 
  1. Store the started synth in var =process=.
  2. map any params that need to be mapped.
  3. add notifiers to the array from the environment of the player, whith actions:
     - set the parameter at the corresponding array slot to the value received
     - set the synth parameter to the value received.

- When issuing release to stop the synth, do:
  - remove all notifiers from the parameter array. The synth is left to fade out without any parameter changes (!).
  - Set the array variable to a new empty array [].

*** Extra feature: Play arrays of synthdefs and/or patterns at each play, sharing the Players environment

To consider! : 

This could be the default behavior.

It means that the player performs set, map, free, release or event merging operations on each of the currently active processes.  The variable process should always contain an array. 

** DONE 19 Jan 2021 12:54 Pseq and Pser with function filter?
   CLOSED: [2021-01-19 Tue 14:12]

   - State "DONE"       from              [2021-01-19 Tue 14:12] \\
     Done. see Pfseq, Pfser.

Devise a Pattern that plays like a Pseq but creates a new array for the Pseq at each new repetition, using a function.  The function should take the initial array, the previous array, and the number of repetitions as argument.

The same with a Pser pattern, using the function to calculate the next index for accessing the list.

** TODO 19 Jan 2021 16:42 check Queue:add: prevent running waitForBoot each time

#+begin_src 
add { | action |
	actions add: action;
	if (inactive) {  // make sure server is booted, then eval first action
		inactive = false; // must be before waitForBoot !!!!!!!
		/* TODO:
			check if it is possible to avoid running
		preboot.(this) and waitForboot, when the server is already running.
		*/
		preboot.(this);
		server.waitForBoot({ // because waitForBoot messes with more delay
			this.changed(\started, Process.elapsedTime);
			this.prNext;
		})
	}
	// if active, wait for sync message from server.
}
#+end_src

** TODO 19 Jan 2021 20:04 document Queue sync mechanism to write own SynthDef loading code

Find what messages from server are used to sync Queue, and which messages from lang trigger these messages.

*** Answer

The queue works by evaluating the first (or next) function in its queue (here called =f=), and then *immediately* sending the message =/sync= to the server. Thus: 

1) First evaluate the function - which may start on the server some task such as loading a buffer or a synthder. 
2) Then send the message =/sync= to the server.

This means that under normal conditions the server will start executing some time consuming task *before* receiving the =/sync= message.  If the task that was started by the evaluated function has already finished by the time that the server receives the subsequent =/sync= message, then the server will *immediately* send back the message =/synced=.  Else, the server will send back the message =/synced= as soon as it has finished the task which it was executing when it received the =/sync= message from Queue. 

The Queue sends the =/sync= message together with a unique id which it obtains from =UniqueID.next=.  In response to this, the server sends back the message =/synced= together with the same id.  The OSCFunc of Queue compares the id received with the one it just generated, and thus makes sure to respond to the =/synced= message which corresponds to the =/sync= message that it just sent. When the ids match, Queue executes the next function in its queue list. 

*** What this means for syncing the loading of synthdefs and starting of synths

For starting of synths we can test this by including a synth.set message in a function that creates a synth, just after Synth.new, and after that syncing, and then in the next action also sending a synth.set message. According to today's tests, one can send both synth.set and synth.map to a synth right after Synth.new, without syncing.  But we may want to test this again ...  . However it would be more interesting to test the same thing with generating a synthdef from a function and sending it to the server, and then immediately trying to start a synth from it before syncing. This should definitely not work. The synth should only be possible to generate in the next function added to the Queue after the synthdef loading function.  This next function is guaranteed to run after the SynthDef has been loaded, and therefore it is guaranteed that this function can start a synth with this synthdef.

** TODO 19 Jan 2021 22:42 Redo synthdef freeing  + controls + bus mechanism from makeSynth of SynthPlayer.

This code is complex and needs rebuilding step-by-step.

Connecting an array of parameters as receiver of update messages from the players envir may improve the code.

** TODO 19 Jan 2021 22:18 enable customization of envelopes in GraphBuilder:wrapPlayerOut

I could not find a way to detect if a synthdef contains a \gate control
from inside GraphBuilder.  But:
An easy way to automate this customization might be to require that the gate
control be written as argument and then check for its presence in the source function like this: 

#+begin_src sclang
{ | gate = 0 | }.def.argNames.includes(\gate);
#+end_src

The relevant code in GraphBuilder is: 
#+begin_src sclang

 GraphBuilder {
	/*
		TODO: add an argument for customizing makeFadeEnv.
		Make it possible to either provide the function itself,
		or the name of a method to call,
		Define different methods for different types of fade envelopes.
		Symbol \none might build as envelope just the number 1, 
		thus canceling the envelope making and allowing the user 
		to write their envelope + gate in the function. 
	*/
	*wrapPlayerOut 
#+end_src
